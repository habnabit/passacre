/*
 * Copyright (c) Aaron Gallagher <_@habnab.it>
 * See COPYING for details.
 */

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]

/* automatically generated by rust-bindgen */

pub type spongeState = ::libc::c_void;

#[repr(C)]
pub struct SkeinCtx_t {
    pub skeinSize: u64,
    pub XSave: [u64; 16usize],
    pub _m: [u64; 36usize],
}

impl Default for SkeinCtx_t {
    fn default() -> SkeinCtx_t {
        SkeinCtx_t {
            skeinSize: Default::default(),
            XSave: Default::default(),
            _m: [0; 36],
        }
    }
}

#[repr(C)]
#[derive(Default)]
pub struct ThreefishKey_t {
    pub stateSize: u64,
    pub key: [u64; 17usize],
    pub tweak: [u64; 3usize],
}

pub const SKEIN_SUCCESS: ::libc::c_int = 0;
pub const Threefish512: ::libc::size_t = 512;
pub const Skein512: ::libc::size_t = 512;

#[link(name = "passacre_deps", kind = "static")]
extern "C" {
    pub fn AllocSponge() -> *mut spongeState;
    pub fn InitSponge(state: *mut spongeState, rate: ::libc::c_uint,
                      capacity: ::libc::c_uint) -> ::libc::c_int;
    pub fn Absorb(state: *mut spongeState, data: *const ::libc::c_uchar,
                  databitlen: ::libc::c_ulonglong) -> ::libc::c_int;
    pub fn Squeeze(state: *mut spongeState, output: *mut ::libc::c_uchar,
                   outputLength: ::libc::c_ulonglong) -> ::libc::c_int;
    pub fn FreeSponge(state: *mut spongeState);
    pub fn skeinCtxPrepare(ctx: *mut SkeinCtx_t, size: ::libc::size_t)
     -> ::libc::c_int;
    pub fn skeinInit(ctx: *mut SkeinCtx_t, hashBitLen: ::libc::size_t)
     -> ::libc::c_int;
    pub fn skeinUpdate(ctx: *mut SkeinCtx_t, msg: *const u8,
                       msgByteCnt: ::libc::size_t) -> ::libc::c_int;
    pub fn skeinFinal(ctx: *mut SkeinCtx_t, hash: *mut u8)
     -> ::libc::c_int;
    pub fn threefishSetKey(keyCtx: *mut ThreefishKey_t,
                           stateSize: ::libc::size_t, keyData: *const u64,
                           tweak: *const u64) -> ();
    pub fn threefishEncryptBlockBytes(keyCtx: *mut ThreefishKey_t,
                                      _in: *const u8, out: *mut u8)
     -> ();
    pub fn crypto_scrypt(arg1: *const u8, arg2: ::libc::size_t,
                         arg3: *const u8, arg4: ::libc::size_t, arg5: u64,
                         arg6: u32, arg7: u32, arg8: *mut u8,
                         arg9: ::libc::size_t) -> ::libc::c_int;
}
